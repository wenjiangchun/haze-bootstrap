// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.3/esri/copyright.txt for details.
//>>built
require({cache:{"url:esri/views/3d/webgl-engine/materials/HUDMaterial.xml":'\x3c?xml version\x3d"1.0" encoding\x3d"UTF-8"?\x3e\r\n\r\n\x3csnippets\x3e\r\n\r\n\x3csnippet name\x3d"HUDMaterialCommonVariables"\x3e\x3c![CDATA[\r\n\tuniform mat4 proj;\r\n\tuniform mat4 view;\r\n\tuniform mat4 model;\r\n\tuniform mat4 modelNormal;\r\n\tuniform vec4 viewport;\r\n\tuniform vec3 camPos;\r\n\tuniform float pixelRatio;\r\n\tuniform vec2 screenOffset;\r\n\tuniform vec2 anchorPos;\r\n\tuniform float polygonOffset;\r\n\tuniform float cameraGroundRelative;\r\n\r\n\tattribute vec3 $position;\r\n\tattribute vec3 $normal;\r\n\tattribute vec2 $uv0;\r\n\tattribute vec4 $color;\r\n  attribute vec2 $size;\r\n  attribute vec4 $auxpos1;\r\n  attribute vec4 $auxpos2;\r\n\r\n\tvarying vec4 vcolor;\r\n\r\n#ifdef OCCL_PIXELSHADER\r\n \tvarying vec4 vtc;\r\n#else\r\n\tvarying vec2 vtc;\r\n\tvarying vec2 vsize;\r\n\tuniform sampler2D framebufferTex;\r\n\tuniform vec3 markerColor;\r\n#endif\r\n\r\n$vvUniforms\r\n\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"matchPixelOrigin"\x3e\x3c![CDATA[\r\n\tvec4 matchPixelOrigin(vec4 clipCoord, vec2 widthHeight) {\r\n\t\tvec2 xy \x3d vec2(.5) + .5 * clipCoord.xy / clipCoord.w;\r\n\t\tvec2 pixelSz \x3d vec2(1.0) / widthHeight;\r\n\t\tvec2 ij \x3d floor((xy + .5 * pixelSz) * widthHeight);\r\n\t\tvec2 result \x3d ((ij * pixelSz) * 2.0 - vec2(1.0)) * clipCoord.w;\r\n\t\treturn vec4(result.x, result.y, clipCoord.z, clipCoord.w);\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"calcPosMatchPixelCenter"\x3e\x3c![CDATA[\r\n\r\n\t\tvec3 posModel \x3d (model * vec4($position, 1.0)).xyz;\r\n\t\tvec3 posView \x3d (view * vec4(posModel, 1.0)).xyz;\r\n\r\n\t\tvec3 vnormal \x3d (modelNormal * vec4($normal, 1.0)).xyz;\r\n\r\n\t\t// groundRelative is 1 if both camera and symbol are on the same side of the ground, -1 otherwise\r\n\t\tfloat pointGroundSign \x3d sign(pointGroundDistance);\r\n\t\tif (pointGroundSign \x3d\x3d 0.0) {\r\n\t\t  pointGroundSign \x3d 1.0;\r\n\t\t}\r\n\r\n\t\tfloat groundRelative \x3d cameraGroundRelative * pointGroundSign;\r\n\t\t// cameraGroundRelative must not be 0 (guaranteed by HUDMaterial.js)\r\n\r\n\t\t// view angle dependent part of polygon offset emulation\r\n\t\t// we take the absolute value because the sign that is dropped is\r\n\t\t// instead introduced using the ground-relative position of the symbol and the camera\r\n\t\tfloat cosAlpha \x3d clamp(dot(vnormal * pointGroundSign, normalize(camPos - posModel)), 0.01, 1.0);\r\n\t\tif (polygonOffset \x3e .0) {\r\n\t\t\tfloat tanAlpha \x3d sqrt(1.0 - cosAlpha * cosAlpha) / cosAlpha;\r\n\t\t\tfloat factor \x3d (1.0 - tanAlpha / viewport[2]);\r\n\t\t\t// same side of the terrain\r\n\t\t\tif (groundRelative \x3e 0.0) {\r\n\t\t\t\tposView *\x3d factor;\r\n\t\t\t}\r\n\t\t\t// opposite sides of the terrain\r\n\t\t\telse {\r\n\t\t\t\tposView /\x3d factor;\r\n\t\t\t}\r\n\t\t}\r\n\r\n    \tposView +\x3d centerOffset;\r\n\r\n\t\tvec4 posProj \x3d proj * vec4(posView, 1.0);\r\n\r\n\t\t// constant part of polygon offset emulation\r\n\t\tposProj.z -\x3d groundRelative * polygonOffset * posProj.w;\r\n\r\n\t\tposProjCenter \x3d matchPixelCenter(posProj, viewport.zw);\r\n\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vertexShaderHUD"\x3e\x3c![CDATA[\r\n    $HUDMaterialCommonVariables\r\n\r\n\t$matchPixelCenter\r\n\t$matchPixelOrigin\r\n\t$vvFunctions\r\n\r\n\tvoid main(void) {\r\n\r\n\t\tvec3 centerOffset \x3d $auxpos1.xyz;\r\n\t\tfloat pointGroundDistance \x3d $auxpos1.w;\r\n\r\n#ifdef VV_SIZE\r\n\t\t// only use width (.xx) for proportional scaling\r\n\t\t// (if no width was defined in vv, width\r\n\t\t//  will be a copy of height vv)\r\n\t\tvec2 inputSize \x3d vvGetScale($auxpos2).xx * $size;\r\n#else\r\n\t\tvec2 inputSize \x3d $size;\r\n#endif\r\n\r\n\t\tvec2 combinedSize \x3d inputSize * pixelRatio;\r\n\r\n\t\tvec4 posProjCenter;\r\n\t\t$calcPosMatchPixelCenter\r\n\r\n#ifdef OCCL_TEST\r\n\t\tif (texture2D(framebufferTex, .5 + .5 * posProjCenter.xy / posProjCenter.w).rgb \x3d\x3d markerColor) {\r\n#endif\r\n\t\t\tvec2 uv01 \x3d floor($uv0);\r\n\t\t\tvec2 uv \x3d $uv0 - uv01;\r\n\t\t\tfloat dist \x3d distance(camPos, posModel);\r\n\t\t\tposProj.xy +\x3d ((uv01 - anchorPos) * 2.0 * combinedSize + screenOffset)/ viewport.zw * posProj.w;\r\n\t\t\tvtc.xy \x3d uv;\r\n\t\t\tvsize \x3d inputSize;\r\n#ifdef OCCL_TEST\r\n\t\t} else {\r\n\t\t\tvtc \x3d vec2(.0);\r\n\t\t}\r\n#endif\r\n\r\n#ifdef OCCL_PIXELSHADER\r\n\tvtc.zw \x3d .5 + .5 * posProjCenter.xy / posProjCenter.w;\r\n#endif\r\n\t\tgl_Position \x3d matchPixelOrigin(posProj, viewport.zw);\r\n\r\n#ifdef VV_COLOR\r\n\t\tvcolor \x3d vvGetColor($auxpos2, vvColorValues, vvColorColors);\r\n#else\r\n\t\tvcolor \x3d $color / 255.0;\r\n#endif\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vertexShaderHUDWorldScale"\x3e\x3c![CDATA[\r\n    $HUDMaterialCommonVariables\r\n\r\n\tuniform vec2 minMaxWorldSizeFactor;\r\n\r\n\t$matchPixelCenter\r\n\t$vvFunctions\r\n\r\n\tvoid main(void) {\r\n\t\tvec3 centerOffset \x3d $auxpos1.xyz;\r\n\t\tfloat pointGroundDistance \x3d $auxpos1.w;\r\n#ifdef VV_SIZE\r\n\t\tvec2 combinedSize \x3d vvGetScale($auxpos2).xy * $size;\r\n#else\r\n\t\tvec2 combinedSize \x3d $size;\r\n#endif\r\n\r\n\t\tvec4 posProjCenter;\r\n\r\n\t\t$calcPosMatchPixelCenter\r\n\r\n#ifdef OCCL_TEST\r\n\t\tif (texture2D(framebufferTex, .5 + .5 * posProjCenter.xy / posProjCenter.w).rgb \x3d\x3d markerColor) {\r\n#endif\r\n\t\t\tfloat scale \x3d 1.0;\r\n\t\t\tvec2 minMaxWorldSize \x3d distance(camPos, position)*minMaxWorldSizeFactor;\r\n\t\t\tif (minMaxWorldSize.x \x3e combinedSize.y)\r\n\t\t\t\tscale \x3d minMaxWorldSize.x / combinedSize.y;\r\n\t\t\telse if (minMaxWorldSize.y \x3e 0.0)\r\n\t\t\t\tscale \x3d min(1.0, minMaxWorldSize.y / combinedSize.y);\r\n\r\n\t\t\tvec2 uv01 \x3d floor($uv0);\r\n\t\t\tvec2 uv \x3d $uv0 - uv01;\r\n\t\t\tposView.xy +\x3d (uv01 - anchorPos) * combinedSize * scale;\r\n\t\t\tvtc.xy \x3d uv;\r\n#ifdef OCCL_TEST\r\n\t\t} else {\r\n\t\t\tvtc \x3d vec2(.0);\r\n\t\t}\r\n#endif\r\n\r\n#ifdef OCCL_PIXELSHADER\r\n\tvtc.zw \x3d .5 + .5 * posProjCenter.xy / posProjCenter.w;\r\n#endif\r\n\t\tposProj \x3d proj * vec4(posView,1.0);\r\n\t\tposProj.xy +\x3d screenOffset / viewport.zw * posProj.w;\r\n\t\tgl_Position \x3d posProj;\r\n\r\n#ifdef VV_COLOR\r\n\t\tvcolor \x3d vvGetColor($auxpos2, vvColorValues, vvColorColors);\r\n#else\r\n\t\tvcolor \x3d $color / 255.0;\r\n#endif\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\r\n\r\n\x3csnippet name\x3d"calcLabelDirections"\x3e\x3c![CDATA[\r\n\tvec2 uv01 \x3d floor($uv0);\r\n\tvec2 uv \x3d $uv0 - uv01;\r\n\r\n\tvec3 labelDir, labelDirOrtho;\r\n\r\n\tint isUp \x3d 0;\r\n\tvec2 vId \x3d (uv01 - vec2(.5, .5))*2.0;\r\n\r\n\tvec3 viewDirInNormalPlane \x3d normalize(camDir.xyz - dot(camDir.xyz, direction)*direction);\r\n\tfloat angleToNormal \x3d abs(dot(viewDirInNormalPlane,up));\r\n\tfloat angleToDirection \x3d abs(dot(camDir.xyz, direction));\r\n\tif (angleToDirection \x3c 0.985 \x26\x26 angleToNormal \x3c 0.500)\r\n\t{\r\n\t    if (angleToNormal \x3c 0.422) {\r\n\t\t    isUp \x3d 1;\r\n\t\t    labelDir \x3d direction;\r\n\t\t    labelDirOrtho \x3d up;\r\n\t\t    vId.y +\x3d 0.5;\r\n\t\t} else {\r\n\t\t    labelDir \x3d direction;\r\n            labelDirOrtho \x3d cross(viewDirInNormalPlane, direction);\r\n            vId.y +\x3d dot(labelDirOrtho, up)*0.5;\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tlabelDir \x3d direction;\r\n\t\tlabelDirOrtho \x3d normalize(cross(up,direction));\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vertexShaderHUDDirection"\x3e\x3c![CDATA[\r\n  $HUDMaterialCommonVariables\r\n  uniform vec3 direction;\r\n\r\n  $matchPixelCenter\r\n\t$vvFunctions\r\n\r\n\tvoid main(void) {\r\n\t\tvec3 centerOffset \x3d $auxpos1.xyz;\r\n\t\tfloat pointGroundDistance \x3d $auxpos1.w;\r\n#ifdef VV_SIZE\r\n\t\tvec2 inputSize \x3d vvGetScale($auxpos2).xy * $size;\r\n#else\r\n\t\tvec2 inputSize \x3d $size;\r\n#endif\r\n\t\tvec2 combinedSize \x3d inputSize * pixelRatio;\r\n\r\n        vec4 posProjCenter;\r\n \t\t$calcPosMatchPixelCenter\r\n\r\n \t\tvec3 up \x3d vnormal;\r\n \t\tvec3 camDir \x3d normalize(vec3(view[0][2],view[1][2],view[2][2]));\r\n\r\n #ifdef OCCL_TEST\r\n \t\tif (texture2D(framebufferTex, .5 + .5 * posProjCenter.xy / posProjCenter.w).rgb \x3d\x3d markerColor) {\r\n #endif\r\n\r\n \t\t\t$calcLabelDirections\r\n\r\n\t\t    float scale;\r\n\t\t    if (proj[2][3] !\x3d 0.0)  // perspective projection\r\n \t\t\t    scale \x3d posProj.w*0.5/viewport[2];\r\n \t\t\telse                    // othographic projection\r\n \t\t\t    scale \x3d 2.0/proj[0][0]/viewport[2];\r\n\r\n \t\t\tposModel.xyz +\x3d labelDir * vId.x * combinedSize.x * scale ;\r\n \t\t\tposModel.xyz +\x3d labelDirOrtho * vId.y * combinedSize.y * scale;\r\n\r\n      // capability to flip upside down was lost when label texture atlases were implemented. this was the old code:\r\n \t\t\t//vec4 posDirProj \x3d proj*view*model * vec4($position+direction, 1.0);\r\n \t\t\t//vec4 posProjUnmodified \x3d proj*view*model * vec4($position, 1.0);\r\n \t\t\t//if (posDirProj.x \x3c posProjUnmodified.x)\r\n \t\t\t//{\r\n \t\t\t//\tif (isUp\x3d\x3d1)\r\n \t\t\t//\t\tuv.x \x3d texScale.x-uv.x;\r\n \t\t\t//\telse\r\n \t\t\t//\t\tuv \x3d texScale-uv;\r\n \t\t\t//}\r\n \t\t\tvtc.xy \x3d uv;\r\n #ifdef OCCL_TEST\r\n \t\t} else {\r\n \t\t\tvtc \x3d vec2(.0);\r\n \t\t}\r\n #endif\r\n\r\n #ifdef OCCL_PIXELSHADER\r\n\tvtc.zw \x3d .5 + .5 * posProjCenter.xy / posProjCenter.w;\r\n#endif\r\n \t\tvec4 pos4 \x3d proj * view * vec4(posModel,1.0);\r\n \t\tgl_Position \x3d pos4;\r\n\r\n#ifdef VV_COLOR\r\n\t\tvcolor \x3d vvGetColor($auxpos2, vvColorValues, vvColorColors);\r\n#else\r\n\t\tvcolor \x3d $color / 255.0;\r\n#endif\r\n \t}\r\n ]]\x3e\x3c/snippet\x3e\r\n\r\n\r\n\x3csnippet name\x3d"vertexShaderHUDDirectionWorldScale"\x3e\x3c![CDATA[\r\n    $HUDMaterialCommonVariables\r\n\r\n\tuniform vec2 minMaxWorldSizeFactor;\r\n\tuniform vec3 direction;\r\n\r\n\t$matchPixelCenter\r\n\t$matchPixelOrigin\r\n\t$vvFunctions\r\n\r\n\tvoid main(void) {\r\n\t\tvec3 centerOffset \x3d $auxpos1.xyz;\r\n\t\tfloat pointGroundDistance \x3d $auxpos1.w;\r\n#ifdef VV_SIZE\r\n\t\tvec2 combinedSize \x3d vvGetScale($auxpos2).xy * $size;\r\n#else\r\n\t\tvec2 combinedSize \x3d $size;\r\n#endif\r\n\r\n\t\tvec4 posProjCenter;\r\n\t\t$calcPosMatchPixelCenter\r\n\r\n\t\tvec3 up \x3d vnormal;\r\n\t\tvec3 camDir \x3d normalize(vec3(view[0][2],view[1][2],view[2][2]));\r\n\r\n#ifdef OCCL_TEST\r\n\t\tif (texture2D(framebufferTex, .5 + .5 * posProjCenter.xy / posProjCenter.w).rgb \x3d\x3d markerColor) {\r\n#endif\r\n\r\n\t\t\t$calcLabelDirections\r\n\r\n\t\t\tfloat scale \x3d 1.0;\r\n\t\t\tvec2 minMaxWorldSize \x3d minMaxWorldSizeFactor;\r\n\t\t\tif (proj[2][3] !\x3d 0.0)  // perspective projection\r\n\t\t\t\tminMaxWorldSize \x3d distance(camPos, position)*minMaxWorldSizeFactor;\r\n\t\t\tif (minMaxWorldSize.x \x3e combinedSize.y)\r\n\t\t\t\tscale \x3d 0.5 * minMaxWorldSize.x / combinedSize.y;\r\n\t\t\telse if (minMaxWorldSize.y \x3e 0.0)\r\n\t\t\t\tscale \x3d 0.5 * min(1.0, minMaxWorldSize.y / combinedSize.y);\r\n\r\n\t\t\tposModel.xyz +\x3d labelDir*vId.x*combinedSize.x*scale;\r\n\t\t\tposModel.xyz +\x3d labelDirOrtho*vId.y*combinedSize.y*scale;\r\n\r\n      // capability to flip upside down was lost when label texture atlases were implemented. this was the old code:\r\n\t\t\t//vec4 posDirProj \x3d proj*view*model * vec4($position+direction, 1.0);\r\n\t\t\t//vec4 posProjUnmodified \x3d proj*view*model * vec4($position, 1.0);\r\n \t\t\t//if (posDirProj.x\x3cposProjUnmodified.x)\r\n \t\t\t//{\r\n \t\t\t//\tif (isUp\x3d\x3d1)\r\n \t\t\t//\t\tuv.x \x3d texScale.x-uv.x;\r\n \t\t\t//\telse\r\n \t\t\t//\t\tuv \x3d texScale-uv;\r\n \t\t\t//}\r\n \t\t\t//uv.y +\x3d (1.0 - texScale.y);\r\n\t\t\tvtc.xy \x3d uv;\r\n#ifdef OCCL_TEST\r\n\t\t} else {\r\n\t\t\tvtc \x3d vec2(.0);\r\n\t\t}\r\n#endif\r\n\r\n#ifdef OCCL_PIXELSHADER\r\n\tvtc.zw \x3d .5 + .5 * posProjCenter.xy / posProjCenter.w;\r\n#endif\r\n\t\tvec4 pos4 \x3d proj * view * vec4(posModel,1.0);\r\n\t\tgl_Position \x3d pos4;\r\n\r\n#ifdef VV_COLOR\r\n\t\tvcolor \x3d vvGetColor($auxpos2, vvColorValues, vvColorColors);\r\n#else\r\n\t\tvcolor \x3d $color / 255.0;\r\n#endif\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fragmentShaderHUDBase"\x3e\x3c![CDATA[\r\n\tprecision mediump float;\r\n\r\n\t#extension GL_OES_standard_derivatives : require\r\n\r\n\tuniform sampler2D tex;\r\n\tuniform vec4 overrideColor;\r\n\tuniform vec4 outlineColor;\r\n\tuniform float outlineSize;\r\n\r\n\tvarying vec4 vcolor;\r\n\r\n#ifdef OCCL_PIXELSHADER\r\n\tvarying vec4 vtc;\r\n\tuniform vec3 markerColor;\r\n\tuniform sampler2D framebufferTex;\r\n#else\r\n\tvarying vec2 vtc;\r\n\tvarying vec2 vsize;\r\n#endif\r\n\r\n\tvoid main() {\r\n\r\n#ifdef OCCL_PIXELSHADER\r\n   \t\tif (texture2D(framebufferTex, vtc.zw).rgb !\x3d markerColor)\r\n   \t\t\tdiscard;\r\n#endif\r\n\r\n#ifdef SIGNED_DISTANCE_FIELD\r\n\t\tvec4 color \x3d vec4(0.0, 0.0, 0.0, 0.0);\r\n\t\tvec4 fillPixelColor \x3d overrideColor * vcolor;\r\n\r\n\t\t// Attempt to sample texel centers to avoid thin cross outline\r\n\t\t// disappearing with large symbol sizes.\r\n\t\t// see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/7058#issuecomment-603041\r\n\t\tconst float txSize \x3d 128.0;\r\n\t\tvec2 scaleFactor \x3d ((vsize - txSize) / txSize);\r\n\t\tvec2 samplePos \x3d vtc + vec2(1.0, -1.0) * (1.0 / txSize) * scaleFactor;\r\n\r\n\t\t// Distance in [-0.5, 0.5]\r\n\t\tfloat d \x3d dot(texture2D(tex, samplePos), vec4(1.0/16777216.0, 1.0/65535.0, 1.0/256.0, 1.0)) - 0.5;\r\n\r\n\t\t// Work around loss of precision for \'d \x3d 0.0\'.\r\n\t\t// \'0\' gets normalised to 0.5 * 256 \x3d 128 before float packing, but can only\r\n\t\t// be stored in the texture as 128 / 255 \x3d 0.502.\r\n\t\t// see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/7058#issuecomment-603110\r\n\t\tconst float diff \x3d (128.0/255.0 - 0.5);\r\n\r\n\t\t// adjust all values, not just those close to 0, to avoid discontinuities in\r\n\t\t// the outlines of other shapes e.g. circles\r\n\t\td \x3d d - diff;\r\n\r\n\t\t// Distance in output units\r\n\t\tfloat dist \x3d d * vsize.x;\r\n\r\n\t\tfillPixelColor.a *\x3d clamp(0.5 - dist, 0.0, 1.0);\r\n\r\n\t\tif (outlineSize \x3e 0.25) {\r\n\t\t\tvec4 outlinePixelColor \x3d outlineColor;\r\n\t\t\tfloat clampedOutlineSize \x3d min(outlineSize, 0.5*vsize.x);\r\n\t\t\toutlinePixelColor.a *\x3d clamp(0.5 - (abs(dist) - 0.5*clampedOutlineSize), 0.0, 1.0);\r\n\r\n\t\t\t// perform un-premultiplied over operator (see https://en.wikipedia.org/wiki/Alpha_compositing#Description)\r\n\t\t\tfloat compositeAlpha \x3d outlinePixelColor.a + fillPixelColor.a * (1.0 - outlinePixelColor.a);\r\n\t\t\tvec3 compositeColor \x3d vec3(outlinePixelColor) * outlinePixelColor.a +\r\n\t\t\t\tvec3(fillPixelColor) * fillPixelColor.a * (1.0 - outlinePixelColor.a);\r\n\t\t\tcompositeColor /\x3d compositeAlpha;\r\n\r\n\t\t\tgl_FragColor \x3d vec4(compositeColor, compositeAlpha);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tgl_FragColor \x3d fillPixelColor;\r\n\t\t}\r\n\r\n\t\t// visualize SDF:\r\n\t\t// gl_FragColor \x3d vec4(clamp(-dist/vsize.x*2.0, 0.0, 1.0), clamp(dist/vsize.x*2.0, 0.0, 1.0), 0.0, 1.0);\r\n#else\r\n\t\tgl_FragColor \x3d texture2D(tex, vtc, -0.5) * overrideColor * vcolor;\r\n#endif\r\n\r\n\t\tif (gl_FragColor.a \x3c 0.1) {\r\n\t\t\tdiscard;\r\n\t\t}\r\n\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fragmentShaderHUD"\x3e\x3c![CDATA[\r\n$fragmentShaderHUDBase\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fragmentShaderHUDHighlight"\x3e\x3c![CDATA[\r\n$fragmentShaderHUDBase\r\n  gl_FragColor \x3d vec4(1.0, 1.0, 1.0, 1.0);\r\n}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\r\n\x3csnippet name\x3d"vertexShaderOcclusionTestPixel"\x3e\x3c![CDATA[\r\n\tuniform mat4 proj;\r\n\tuniform mat4 view;\r\n\tuniform mat4 model;\r\n\tuniform mat4 modelNormal;\r\n\tuniform vec4 viewport;\r\n\tuniform vec3 camPos;\r\n\tuniform float polygonOffset;\r\n\tuniform float cameraGroundRelative;\r\n\r\n\tattribute vec3 $position;\r\n\tattribute vec3 $normal;\r\n\tattribute vec4 $auxpos1;\r\n\r\n\t$matchPixelCenter\r\n\r\n\tvoid main(void) {\r\n\t    vec3 centerOffset \x3d $auxpos1.xyz;\r\n\t\tfloat pointGroundDistance \x3d $auxpos1.w;\r\n\r\n\t    vec4 posProjCenter;\r\n\t    if (dot($position, $position) \x3e 0.0) {\r\n\t\t    $calcPosMatchPixelCenter\r\n\t\t} else {\r\n\t\t    posProjCenter \x3d vec4(1e038, 1e038, 1e038, 1.0);\r\n\t\t}\r\n\r\n\t\tgl_Position \x3d posProjCenter;\r\n\t\tgl_PointSize \x3d 1.0;\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3c/snippets\x3e\r\n'}});
define("dojo/_base/lang dojo/text!./HUDMaterial.xml ./internal/MaterialUtil ../lib/ShaderVariations ../lib/Util ../lib/gl-matrix ../lib/RenderSlot ../../../webgl/Program ../lib/DefaultVertexAttributeLocations ../../../webgl/Util".split(" "),function(L,N,t,M,A,F,G,O,P,w){function H(a,f,q){q[0]=a[0]*(f[2]-f[0])+f[0];q[1]=a[1]*(f[3]-f[1])+f[1]}var I=F.vec2d,z=F.vec3d,J=F.mat4d,C=A.assert,f=A.VertexAttrConstants,K={"bottom-left":[0,0],bottom:[.5,0],"bottom-right":[1,0],left:[0,.5],center:[.5,.5],right:[1,
.5],"top-left":[0,1],top:[.5,1],"top-right":[1,1]},B=[253/255,231/255,229/255];A=function(a,x){t.basicMaterialConstructor(this,x);a=a||null;a.texCoordScale=a.texCoordScale||[1,1];a.occlusionTest=void 0!==a.occlusionTest?a.occlusionTest:!0;a.color=a.color||[1,1,1,1];a.screenMinMaxSize=a.screenMinMaxSize||[0,1E5];a.outlineColor=a.outlineColor||[1,1,1,1];a.outlineSize=a.outlineSize||0;a.textureIsSignedDistanceField=a.textureIsSignedDistanceField?1:0;a.distanceFieldBoundingBox=a.distanceFieldBoundingBox;
a.vvSizeEnabled=a.vvSizeEnabled||!1;a.vvSizeMinSize=a.vvSizeMinSize||[1,1,1];a.vvSizeMaxSize=a.vvSizeMaxSize||[100,100,100];a.vvSizeOffset=a.vvSizeOffset||[0,0,0];a.vvSizeFactor=a.vvSizeFactor||[1,1,1];a.vvColorEnabled=a.vvColorEnabled||!1;a.vvColorValues=a.vvColorValues||[0,0,0,0,0,0,0,0];a.vvColorColors=a.vvColorColors||[1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0];a.screenOffset?a.screenOffset.forEach(function(b,p){a.screenOffset[p]=2*b}):a.screenOffset=[0,0];"string"===typeof a.anchorPos?
(C(K[a.anchorPos],"HUDMaterial: invalid anchorPos specified"),a.anchorPos=K[a.anchorPos]):a.anchorPos||(a.anchorPos=K.center);null==a.shaderPolygonOffset&&(a.shaderPolygonOffset=1E-5);var q=[{name:"position",count:3,type:5126,offset:0,stride:76,normalized:!1},{name:"normal",count:3,type:5126,offset:12,stride:76,normalized:!1},{name:"uv0",count:2,type:5126,offset:24,stride:76,normalized:!1},{name:"color",count:4,type:5121,offset:32,stride:76,normalized:!1},{name:"size",count:2,type:5126,offset:36,
stride:76,normalized:!1},{name:"auxpos1",count:4,type:5126,offset:44,stride:76,normalized:!1},{name:"auxpos2",count:4,type:5126,offset:60,stride:76,normalized:!1}],y=w.getStride(q),b=y/4;this.dispose=function(){};this.getParameterValues=function(){var b={color:a.color,texCoordScale:a.texCoordScale,polygonOffset:a.polygonOffset,anchorPos:a.anchorPos,screenOffset:a.screenOffset,screenMinMaxSize:a.screenMinMaxSize,shaderPolygonOffset:a.shaderPolygonOffset,textureIsSignedDistanceField:a.textureIsSignedDistanceField,
outlineColor:a.outlineColor,outlineSize:a.outlineSize,distanceFieldBoundingBox:a.distanceFieldBoundingBox,vvSizeEnabled:a.vvSizeEnabled,vvSizeMinSize:a.vvSizeMinSize,vvSizeMaxSize:a.vvSizeMaxSize,vvSizeOffset:a.vvSizeOffset,vvSizeFactor:a.vvSizeFactor,vvColorEnabled:a.vvColorEnabled,vvColorValues:a.vvColorValues,vvColorColors:a.vvColorColors};a.textureId&&(b.textureId=a.textureId);a.direction&&(b.direction=a.direction);return b};this.setParameterValues=function(b){for(var p in b)"textureId"===p&&
C(a.textureId,"Can only change texture of material that already has a texture"),"direction"===p&&C(a.direction,"Can only change direction of HUDMaterial which was initialized with a direction"),a[p]=b[p];this.notifyDirty("matChanged")};this.getParams=function(){return a};this.getOutputAmount=function(a){return a*b*6};this.getVertexBufferLayout=function(){return q};this.fillInterleaved=function(d,p,h,e,g,l){var k=4*l;e=t.fill;for(var r=d.faces.indices[f.POSITION],u=d.vertexAttr[f.POSITION].data,c=
l+w.findAttribute(q,f.POSITION).offset/4,n=0;n<r.length;++n){var m=3*r[n];e(u,m,g,c,p,3);c+=b;e(u,m,g,c,p,3);c+=b;e(u,m,g,c,p,3);c+=b;e(u,m,g,c,p,3);c+=b;e(u,m,g,c,p,3);c+=b;e(u,m,g,c,p,3);c+=b}p=d.faces.indices[f.NORMAL];u=d.vertexAttr[f.NORMAL].data;c=l+w.findAttribute(q,f.NORMAL).offset/4;for(n=0;n<p.length;++n)m=3*p[n],e(u,m,g,c,h,3),c+=b,e(u,m,g,c,h,3),c+=b,e(u,m,g,c,h,3),c+=b,e(u,m,g,c,h,3),c+=b,e(u,m,g,c,h,3),c+=b,e(u,m,g,c,h,3),c+=b;c=l+w.findAttribute(q,f.UV0).offset/4;n=d.vertexAttr[f.UV0].data;
null==n||3>=n.length?(h=m=0,p=a.texCoordScale[0],u=a.texCoordScale[1]):(m=d.vertexAttr[f.UV0].data[0],h=d.vertexAttr[f.UV0].data[1],p=d.vertexAttr[f.UV0].data[2],u=d.vertexAttr[f.UV0].data[3]);p=Math.min(1.99999,p+1);u=Math.min(1.99999,u+1);for(n=0;n<r.length;++n)g[c]=m,g[c+1]=h,c+=b,g[c]=p,g[c+1]=h,c+=b,g[c]=p,g[c+1]=u,c+=b,g[c]=p,g[c+1]=u,c+=b,g[c]=m,g[c+1]=u,c+=b,g[c]=m,g[c+1]=h,c+=b;r=d.faces.indices[f.COLOR];h=d.vertexAttr[f.COLOR].data;c=k+w.findAttribute(q,f.COLOR).offset;k=new Uint8Array(g.buffer);
for(n=0;n<r.length;++n)m=4*r[n],e(h,m,k,c,null,4),c+=y,e(h,m,k,c,null,4),c+=y,e(h,m,k,c,null,4),c+=y,e(h,m,k,c,null,4),c+=y,e(h,m,k,c,null,4),c+=y,e(h,m,k,c,null,4),c+=y;k=d.faces.indices[f.SIZE];m=d.vertexAttr[f.SIZE].data;c=l+w.findAttribute(q,f.SIZE).offset/4;for(n=0;n<k.length;++n)r=m[2*k[n]],h=m[2*k[n]+1],g[c]=r,g[c+1]=h,c+=b,g[c]=r,g[c+1]=h,c+=b,g[c]=r,g[c+1]=h,c+=b,g[c]=r,g[c+1]=h,c+=b,g[c]=r,g[c+1]=h,c+=b,g[c]=r,g[c+1]=h,c+=b;if(null!=d.faces.indices[f.AUXPOS1]&&null!=d.vertexAttr[f.AUXPOS1])for(k=
d.faces.indices[f.AUXPOS1],r=d.vertexAttr[f.AUXPOS1].data,c=l+w.findAttribute(q,"auxpos1").offset/4,n=0;n<k.length;++n)m=4*k[n],e(r,m,g,c,null,4),c+=b,e(r,m,g,c,null,4),c+=b,e(r,m,g,c,null,4),c+=b,e(r,m,g,c,null,4),c+=b,e(r,m,g,c,null,4),c+=b,e(r,m,g,c,null,4),c+=b;if(null!=d.faces.indices[f.AUXPOS2]&&null!=d.vertexAttr[f.AUXPOS2])for(k=d.faces.indices[f.AUXPOS2],d=d.vertexAttr[f.AUXPOS2].data,c=l+w.findAttribute(q,"auxpos2").offset/4,n=0;n<k.length;++n)m=4*k[n],e(d,m,g,c,null,4),c+=b,e(d,m,g,c,null,
4),c+=b,e(d,m,g,c,null,4),c+=b,e(d,m,g,c,null,4),c+=b,e(d,m,g,c,null,4),c+=b,e(d,m,g,c,null,4),c+=b};var v=z.create(),k=z.create(),d=J.create();J.identity(d);var e=[0,0],l=[0,0];this.intersect=function(b,p,h,q,g,x,y,r){if(q.isSelection&&q.enableHUDSelection){g=p=1;r&&(g=r(d),p=g[0],g=g[5]);r=b.getData().getVertexAttr()[f.POSITION];b=b.getData().getVertexAttr()[f.SIZE];C(3<=r.size);x=q.point;var u=q.camera;a.textureIsSignedDistanceField?H(a.anchorPos,a.distanceFieldBoundingBox,l):I.set(a.anchorPos,
l);for(var c=0;c<r.data.length/r.size;c++){var n=c*r.size;z.set3(r.data[n],r.data[n+1],r.data[n+2],v);J.multiplyVec3(h,v,v);n=c*b.size;e[0]=b.data[n]*p;e[1]=b.data[n+1]*g;u.projectPoint(v,k);if(-1<k[0]){var n=k[0]-1-(0<l[0]?e[0]*l[0]:0),m=n+e[0]+2,t=k[1]-1-(0<l[1]?e[1]*l[1]:0),w=t+e[1]+2;if(a.textureIsSignedDistanceField)var D=a.outlineSize/2,E=a.distanceFieldBoundingBox,n=n+e[0]*E[0],t=t+e[1]*E[1],m=m-e[0]*(1-E[2]),w=w-e[1]*(1-E[3]),n=n-D,m=m+D,t=t-D,w=w+D;x[0]>n&&x[0]<m&&x[1]>t&&x[1]<w&&(m=q.p0,
t=q.p1,k[0]=x[0],k[1]=x[1],u.unprojectPoint(k,v),n=z.negate(q.getDirection(),z.create()),m=z.dist(m,v)/z.dist(m,t),y(m,n,-1,1,!0))}}}};this.getGLMaterials=function(){return{color:Q,depthShadowMap:void 0,normal:void 0,depth:void 0,highlight:R}};this.getAllTextureIds=function(){return[a.textureId]};this._textureDirty=!1;this.setTextureDirty=function(){this._textureDirty=!0}};var Q=function(a,f,q){function x(){return f.shaderVariators.HUDMaterial.getProgram([!!d.direction,!!d.worldScale,d.occlusionTest,
d.textureIsSignedDistanceField,!!d.vvSizeEnabled,!!d.vvColorEnabled])}t.basicGLMaterialConstructor(this,a);var b=G.OCCLUSION_PIXELS,v=G.OVERLAY,k=0,d=L.clone(a.getParams()),e=f.get("hudOcclusionTestPixel"),l=x();t.singleTextureGLMaterialConstructor(this,q,d);this.beginSlot=function(a){k=a;return d.occlusionTest?a===b||a===v:a===v};this.getProgram=function(){return k===b&&d.occlusionTest?e:l};this.getAllPrograms=function(){return[e,l]};this.updateParameters=function(){var b=a.getParams();d.color=b.color;
d.texCoordScale=b.texCoordScale;d.polygonOffset=b.polygonOffset;d.anchorPos=b.anchorPos;d.screenOffset=b.screenOffset;d.screenMinMaxSize=b.screenMinMaxSize;d.direction=b.direction;d.shaderPolygonOffset=b.shaderPolygonOffset;d.textureIsSignedDistanceField=b.textureIsSignedDistanceField;d.outlineColor=b.outlineColor;d.outlineSize=b.outlineSize;d.vvSizeEnabled=b.vvSizeEnabled;d.vvSizeMinSize=b.vvSizeMinSize;d.vvSizeMaxSize=b.vvSizeMaxSize;d.vvSizeOffset=b.vvSizeOffset;d.vvSizeFactor=b.vvSizeFactor;d.vvColorEnabled=
b.vvColorEnabled;d.vvColorValues=b.vvColorValues;d.vvColorColors=b.vvColorColors;this.updateTexture(b.textureId);l=x()};var w=[0,0];this.bind=function(p,h){a._textureDirty&&(this.renderTexture(p),a._textureDirty=!1);var f=p.gl,g=h.cameraAboveGround?1:-1;if(k===b&&d.occlusionTest)p.bindProgram(e),e.setUniform1f("cameraGroundRelative",g),e.setUniform1f("polygonOffset",d.shaderPolygonOffset),e.setUniform4fv("viewport",h.viewport),e.setUniform4f("color",B[0],B[1],B[2],1),p.setDepthFunction(f.LEQUAL);
else{p.bindProgram(l);l.setUniform1f("cameraGroundRelative",g);this.bindTexture(p,l);l.setUniform1i("framebufferTex",1);p.bindTexture(h.framebufferTex,1);p.setActiveTexture(0);l.setUniform3fv("markerColor",B);l.setUniform4fv("viewport",h.viewport);l.setUniform4fv("overrideColor",d.color);l.setUniform1f("pixelRatio",h.pixelRatio);l.setUniform1f("polygonOffset",d.shaderPolygonOffset);d.textureIsSignedDistanceField&&(l.setUniform4fv("outlineColor",d.outlineColor),l.setUniform1f("outlineSize",d.outlineSize));
d.vvSizeEnabled&&(l.setUniform3fv("vvSizeMinSize",d.vvSizeMinSize),l.setUniform3fv("vvSizeMaxSize",d.vvSizeMaxSize),l.setUniform3fv("vvSizeOffset",d.vvSizeOffset),l.setUniform3fv("vvSizeFactor",d.vvSizeFactor));d.vvColorEnabled&&(l.setUniform1fv("vvColorValues",d.vvColorValues),l.setUniform4fv("vvColorColors",d.vvColorColors));if(d.worldScale){var f=[-1,-1],g=d.screenMinMaxSize,q=h.proj;h=h.viewport[2]/h.pixelRatio;g&&(0!==q[11]?(h=Math.tan(2*Math.atan(1/q[0])/2)/h*2,f[0]=g[0]*h,f[1]=g[1]*h):I.scale(g,
2/(q[0]*h),f));l.setUniform2fv("minMaxWorldSizeFactor",f)}d.direction&&l.setUniform3fv("direction",d.direction);l.setUniform2fv("texScale",d.texCoordScale);l.setUniform2fv("screenOffset",d.screenOffset);d.textureIsSignedDistanceField?(H(d.anchorPos,d.distanceFieldBoundingBox,w),l.setUniform2fv("anchorPos",w)):l.setUniform2fv("anchorPos",d.anchorPos);d.polygonOffset&&(p.setPolygonOffsetFillEnabled(!0),p.setPolygonOffset(0,-4));p.setBlendingEnabled(!0)}};this.release=function(a){var e=a.gl;k===b&&d.occlusionTest?
a.setDepthFunction(e.LESS):(a.setPolygonOffsetFillEnabled(!1),a.setBlendingEnabled(!1))};this.bindView=function(a,h){a=h.origin;k===b&&d.occlusionTest?(t.bindView(a,h.view,e),t.bindCamPos(a,h.viewInvTransp,e)):(t.bindView(a,h.view,l),t.bindCamPos(a,h.viewInvTransp,l))};this.bindInstance=function(a,h){k===b&&d.occlusionTest?(e.setUniformMatrix4fv("model",h.transformation),e.setUniformMatrix4fv("modelNormal",h.transformationNormal)):l.setUniformMatrix4fv("model",h.transformation)};this.getDrawMode=
function(a){a=a.gl;return k===b&&d.occlusionTest?a.POINTS:a.TRIANGLES}},R=function(a,f,q){function x(){return f.shaderVariators.HUDMaterialHighlight.getProgram([!!b.direction,!!b.worldScale,b.occlusionTest,b.textureIsSignedDistanceField,!!b.vvSizeEnabled,!!b.vvColorEnabled])}t.basicGLMaterialConstructor(this,a);var b=L.clone(a.getParams()),v=f.get("hudOcclusionTestPixel"),k=x();t.singleTextureGLMaterialConstructor(this,q,b);this.beginSlot=function(a){return a===G.OVERLAY};this.getProgram=function(){return k};
this.getAllPrograms=function(){return[v,k]};this.updateParameters=function(){var d=a.getParams();b.color=d.color;b.texCoordScale=d.texCoordScale;b.polygonOffset=d.polygonOffset;b.anchorPos=d.anchorPos;b.screenOffset=d.screenOffset;b.screenMinMaxSize=d.screenMinMaxSize;b.direction=d.direction;b.shaderPolygonOffset=d.shaderPolygonOffset;b.textureIsSignedDistanceField=d.textureIsSignedDistanceField;b.outlineColor=d.outlineColor;b.outlineSize=d.outlineSize;this.updateTexture(d.textureId);k=x()};var d=
[0,0];this.bind=function(e,l){a._textureDirty&&(this.renderTexture(e),a._textureDirty=!1);e.bindProgram(k);this.bindTexture(e,k);k.setUniform1i("framebufferTex",1);e.bindTexture(l.framebufferTex,1);e.setActiveTexture(0);k.setUniform3fv("markerColor",B);k.setUniform4fv("viewport",l.viewport);k.setUniform4fv("overrideColor",b.color);k.setUniform1f("pixelRatio",l.pixelRatio);k.setUniform1f("polygonOffset",b.shaderPolygonOffset);b.textureIsSignedDistanceField&&(k.setUniform4fv("outlineColor",b.outlineColor),
k.setUniform1f("outlineSize",b.outlineSize));if(b.worldScale){var f=[-1,-1],p=b.screenMinMaxSize,h=l.proj;l=l.viewport[2]/l.pixelRatio;p&&(0!==h[11]?(h=Math.tan(2*Math.atan(1/h[0])/2)/l*2,f[0]=p[0]*h,f[1]=p[1]*h):I.scale(p,2/(h[0]*l),f));k.setUniform2fv("minMaxWorldSizeFactor",f)}b.direction&&k.setUniform3fv("direction",b.direction);k.setUniform2fv("texScale",b.texCoordScale);k.setUniform2fv("screenOffset",b.screenOffset);b.textureIsSignedDistanceField?(H(b.anchorPos,b.distanceFieldBoundingBox,d),
k.setUniform2fv("anchorPos",d)):k.setUniform2fv("anchorPos",b.anchorPos);b.polygonOffset&&(e.setPolygonOffsetFillEnabled(!0),e.setPolygonOffset(0,-4));e.setBlendingEnabled(!0)};this.release=function(a){a.setPolygonOffsetFillEnabled(!1);a.setBlendingEnabled(!1)};this.bindView=function(a,b){a=b.origin;t.bindView(a,b.view,k);t.bindCamPos(a,b.viewInvTransp,k)};this.bindInstance=function(a,b){k.setUniformMatrix4fv("model",b.transformation)};this.getDrawMode=function(a){return a.gl.TRIANGLES}};A.loadShaders=
function(a,f,q,t){a._parse(N);var b=0<t.parameters.maxVertexTextureImageUnits,v=new M("hud",["vertexShaderHUD","fragmentShaderHUD"],null,q,f,a,t);v.addBinaryShaderSnippetSuffix("Direction","Direction",[!0,!1]);v.addBinaryShaderSnippetSuffix("WorldScale","WorldScale",[!0,!1]);v.addDefine("OcclTest",b?"OCCL_TEST":"OCCL_PIXELSHADER");v.addDefine("SDF","SIGNED_DISTANCE_FIELD");v.addDefine("vvSize","VV_SIZE");v.addDefine("vvColor","VV_COLOR");q.shaderVariators.HUDMaterial=v;f=new M("hudHighlight",["vertexShaderHUD",
"fragmentShaderHUDHighlight"],null,q,f,a,t);f.addBinaryShaderSnippetSuffix("Direction","Direction",[!0,!1]);f.addBinaryShaderSnippetSuffix("WorldScale","WorldScale",[!0,!1]);f.addDefine("OcclTest",b?"OCCL_TEST":"OCCL_PIXELSHADER");f.addDefine("SDF","SIGNED_DISTANCE_FIELD");f.addDefine("vvSize","VV_SIZE");f.addDefine("vvColor","VV_COLOR");q.shaderVariators.HUDMaterialHighlight=f;a=new O(t,a.vertexShaderOcclusionTestPixel,a.fragmentShaderSimple,P.Default3D);q.add("hudOcclusionTestPixel",a)};return A});